#!/usr/bin/env node

/**
 * Build-time theme generator for DRY SSG theme system
 * Reads Directus hotel configurations and generates static CSS and font URLs
 *
 * This script implements the DRY principle where Directus is the single source of truth
 * for all theme configuration, generating static assets at build time for SSG.
 */

// Load environment variables from .env file
import dotenv from 'dotenv';
dotenv.config();

import { mkdirSync, writeFileSync } from "node:fs";
import { dirname } from "node:path";
import { createDirectus, readItems, rest, staticToken } from "@directus/sdk";
import fetch from "node-fetch";

// Directus configuration - using the same URLs as the main project
const DIRECTUS_URL = process.env.DIRECTUS_URL || "https://hotels.daotomata.io";
const DIRECTUS_TOKEN =
  process.env.DIRECTUS_ADMIN_TOKEN || "rYncRSsu41KQQLvZYczPJyC8-8yzyED3";

// Output paths
const THEMES_CSS_PATH = "src/styles/themes.css";
const FONTS_CONFIG_PATH = "src/generated/fonts-config.json";

/**
 * Initialize Directus client with proper authentication and fetch polyfill
 */
function createDirectusClient() {
  const client = createDirectus(DIRECTUS_URL, {
    globals: {
      fetch: fetch,
    },
  })
    .with(rest())
    .with(staticToken(DIRECTUS_TOKEN));

  return client;
}

/**
 * Fetch current hotel with theme configuration from Directus (Single-tenant)
 */
async function fetchCurrentHotelFromDirectus() {
  const hotelId = process.env.HOTEL_ID || '1';
  console.log(`üîÑ Fetching hotel ID ${hotelId} from Directus...`);

  const client = createDirectusClient();

  try {
    const hotels = await client.request(
      readItems("hotels", {
        filter: { id: { _eq: hotelId } },
        fields: ["id", "name", "domain", "theme"],
        limit: 1,
      }),
    );

    if (!hotels || hotels.length === 0) {
      throw new Error(`Hotel with ID ${hotelId} not found`);
    }

    const hotel = hotels[0];
    console.log(`‚úÖ Fetched hotel: ${hotel.name} (ID: ${hotel.id})`);
    return hotel;
  } catch (error) {
    console.error("‚ùå Error fetching hotel from Directus:", error);
    throw error;
  }
}

/**
 * Fetch all hotels with theme configuration from Directus (DEPRECATED - for backward compatibility)
 */
async function _fetchHotelsFromDirectus() {
  console.warn("‚ö†Ô∏è fetchHotelsFromDirectus() is deprecated in single-tenant mode. Use fetchCurrentHotelFromDirectus() instead.");

  const hotel = await fetchCurrentHotelFromDirectus();
  return [hotel]; // Return array for backward compatibility
}

/**
 * Generate DaisyUI theme CSS from hotel configuration
 * Matches the exact format that currently works in themes.css
 */
function generateThemeCSS(hotel) {
  if (!hotel?.theme) {
    console.warn(`‚ö†Ô∏è  No theme configuration found for hotel: ${hotel?.name}`);
    return "";
  }

  const theme = hotel.theme;
  console.log(`üé® Generating theme CSS for: ${hotel.name} (${theme.name})`);

  // Generate @plugin "daisyui/theme" CSS block matching current working format
  const themeCSS = `
/* ${hotel.name} Theme - From Directus */
[data-theme="${theme.name}"] {
  color-scheme: ${theme["color-scheme"] || "light"} !important;

  /* OKLCH Colors from Directus */
${Object.entries(theme.colors || {})
  .map(([key, value]) => `  ${key}: ${value};`)
  .join("\n")}

  /* Layout from Directus */
${Object.entries(theme.layout || {})
  .map(([key, value]) => `  ${key}: ${value};`)
  .join("\n")}

  /* Sizes from Directus */
${Object.entries(theme.sizes || {})
  .map(([key, value]) => `  ${key}: ${value};`)
  .join("\n")}

  /* Effects from Directus */
${Object.entries(theme.effects || {})
  .map(([key, value]) => `  ${key}: ${value};`)
  .join("\n")}
}

/* Force light mode even with dark system preference */
@media (prefers-color-scheme: dark) {
  [data-theme="${theme.name}"] {
    color-scheme: light !important;
  }
}`;

  return themeCSS;
}

/**
 * Generate complete themes.css file with all hotel themes
 */
function generateCompleteThemesCSS(hotels) {
  console.log("üé® Generating complete themes.css file...");

  const header = `/* DaisyUI Custom Themes - Generated from Directus Configuration */
/* This file is automatically generated at build time - DO NOT EDIT MANUALLY */
/* Source: Directus hotels collection theme configurations */
/* Generated: ${new Date().toISOString()} */

@import "tailwindcss";
@plugin "daisyui";
`;

  const themesCSS = hotels
    .filter((hotel) => hotel.theme) // Only hotels with theme configuration
    .map((hotel) => generateThemeCSS(hotel))
    .join("\n");

  return header + themesCSS;
}

/**
 * Generate Google Fonts URL from font configuration
 */
function generateGoogleFontsURL(fontName, weight = "400", style = "normal") {
  const encodedFontName = fontName.replace(/\s+/g, "+");

  if (style === "italic") {
    return `family=${encodedFontName}:ital,wght@1,${weight}`;
  } else {
    return `family=${encodedFontName}:wght@${weight}`;
  }
}

/**
 * Generate Google Fonts configuration from hotel themes
 */
function generateFontsConfig(hotels) {
  console.log("üî§ Generating fonts configuration...");

  const fontsConfig = {
    generated: new Date().toISOString(),
    hotels: {},
  };

  for (const hotel of hotels) {
    if (!hotel.theme?.fonts) continue;

    const fonts = hotel.theme.fonts;

    // Generate individual font URLs
    const fontQueries = [];

    if (fonts.primary) {
      const fontName = fonts.primary.name || fonts.primary;
      const weight = fonts.primary.weight || "400";
      const style = fonts.primary.style || "normal";
      fontQueries.push(generateGoogleFontsURL(fontName, weight, style));
    }

    if (fonts.secondary) {
      const fontName = fonts.secondary.name || fonts.secondary;
      const weight = fonts.secondary.weight || "400";
      const style = fonts.secondary.style || "normal";
      // Only add if different from primary
      if (fontName !== (fonts.primary.name || fonts.primary)) {
        fontQueries.push(generateGoogleFontsURL(fontName, weight, style));
      }
    }

    if (fonts.mono) {
      const fontName = fonts.mono.name || fonts.mono;
      const weight = fonts.mono.weight || "400";
      const style = fonts.mono.style || "normal";
      // Only add if different from primary and secondary
      const primaryName = fonts.primary.name || fonts.primary;
      const secondaryName = fonts.secondary.name || fonts.secondary;
      if (fontName !== primaryName && fontName !== secondaryName) {
        fontQueries.push(generateGoogleFontsURL(fontName, weight, style));
      }
    }

    if (fonts.detail) {
      const fontName = fonts.detail.name || fonts.detail;
      const weight = fonts.detail.weight || "400";
      const style = fonts.detail.style || "normal";
      // Only add if different from other fonts
      const primaryName = fonts.primary.name || fonts.primary;
      const secondaryName = fonts.secondary.name || fonts.secondary;
      const monoName = fonts.mono.name || fonts.mono;
      if (
        fontName !== primaryName &&
        fontName !== secondaryName &&
        fontName !== monoName
      ) {
        fontQueries.push(generateGoogleFontsURL(fontName, weight, style));
      }
    }

    // Build complete Google Fonts URL
    const baseURL = "https://fonts.googleapis.com/css2?";
    const displayQuery = "&display=swap";
    const googleFontsURL = `${baseURL}${fontQueries.join("&")}${displayQuery}`;

    fontsConfig.hotels[hotel.name] = {
      themeName: hotel.theme.name,
      fonts: {
        primary: fonts.primary.name || fonts.primary || "Inter",
        secondary:
          fonts.secondary.name || fonts.secondary || "Playfair Display",
        mono: fonts.mono.name || fonts.mono || "JetBrains Mono",
        detail: fonts.detail.name || fonts.detail || "Inter",
      },
      weights: {
        primary: fonts.primary.weight || "400",
        secondary: fonts.secondary.weight || "400",
        mono: fonts.mono.weight || "400",
        detail: fonts.detail.weight || "400",
      },
      styles: {
        primary: fonts.primary.style || "normal",
        secondary: fonts.secondary.style || "normal",
        mono: fonts.mono.style || "normal",
        detail: fonts.detail.style || "normal",
      },
      googleFontsURL: googleFontsURL,
    };

    console.log(`üî§ Generated fonts config for: ${hotel.name}`);
    console.log(`üî§ Google Fonts URL: ${googleFontsURL}`);
  }

  return fontsConfig;
}

/**
 * Write generated files to disk
 */
function writeGeneratedFiles(themesCSS, fontsConfig) {
  console.log("üíæ Writing generated files...");

  // Ensure directories exist
  mkdirSync(dirname(THEMES_CSS_PATH), { recursive: true });
  mkdirSync(dirname(FONTS_CONFIG_PATH), { recursive: true });

  // Write themes.css
  writeFileSync(THEMES_CSS_PATH, themesCSS, "utf8");
  console.log(`‚úÖ Generated: ${THEMES_CSS_PATH}`);

  // Write fonts configuration
  writeFileSync(
    FONTS_CONFIG_PATH,
    JSON.stringify(fontsConfig, null, 2),
    "utf8",
  );
  console.log(`‚úÖ Generated: ${FONTS_CONFIG_PATH}`);
}

/**
 * Main theme generation function (Single-tenant)
 */
async function generateThemes() {
  console.log("üöÄ Starting single-tenant theme generation from Directus...");
  console.log(`üì° Directus URL: ${DIRECTUS_URL}`);
  console.log(`üè® Hotel ID: ${process.env.HOTEL_ID || '1'}`);

  try {
    // Fetch current hotel from Directus
    const hotel = await fetchCurrentHotelFromDirectus();

    if (!hotel) {
      console.error("‚ùå No hotel found in Directus");
      return;
    }

    // Generate CSS and fonts configuration for single hotel
    const themesCSS = generateCompleteThemesCSS([hotel]);
    const fontsConfig = generateFontsConfig([hotel]);

    // Write files
    writeGeneratedFiles(themesCSS, fontsConfig);

    console.log(`‚úÖ Single-tenant theme generation completed for: ${hotel.name}!`);
    console.log(`üìä Generated theme for hotel: ${hotel.name} (ID: ${hotel.id})`);
  } catch (error) {
    console.error("‚ùå Theme generation failed:", error);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  generateThemes();
}

export { generateThemes };
